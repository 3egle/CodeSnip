# Base for Vue.js File with TypeScript
snippet vbase
	<template>
		<div>
	
		</div>
	</template>
	
	<script lang="ts">
		import Vue from "vue";
	
		export default Vue.extend({
			${0}
		});
	</script>
	
	<style scoped>
	
	</style>
	
# Base with VueConstructor for Vue.js File with TypeScript
snippet vcbase
	<template>
		<div>
	
		</div>
	</template>
	
	<script lang="ts">
		import Vue, { VueConstructor } from "vue";
	
		export default (Vue as VueConstructor<Vue>).extend({
			${0}
		});
	</script>
	
	<style scoped>
	
	</style>
	
# Base with VueConstructor extending interface for Vue.js File with TypeScript
snippet vcibase
	<template>
		<div>
	
		</div>
	</template>
	
	<script lang="ts">
		import Vue, { VueConstructor } from "vue";
		import ${1:NameComponent} from "@/components/${1:NameComponent}.vue";
	
		interface Refs {
			\$refs: {
				${2:aliasComponent}: InstanceType<typeof ${1:NameComponent}>,
			}
		}
		export default (Vue as VueConstructor<Vue & Refs>).extend({
			${0}
		});
	</script>
	
	<style scoped>
	
	</style>
	
# Base class-style API for Vue.js File with TypeScript
snippet vcsbase
	<template>
		<div>
	
		</div>
	</template>
	
	<script lang="ts">
		import Vue from "vue";
		import Component from "vue-class-component";
	
		@Component({})
		export default class ${1:App} extends Vue {
			${0}
		};
	</script>
	
	<style scoped>
	
	</style>
	
# Base class-style API extending Props for Vue.js File with TypeScript
snippet vcsibase
	<template>
		<div>
	
		</div>
	</template>
	
	<script lang="ts">
		import Vue from "vue";
		import Component from "vue-class-component";
	
		const ${1:App}Props = Vue.extend({
			props: {
				${2:nameProp}: ${3:type}
			}
		})
	
		@Component({})
		export default class ${1:App} extends ${1:App}Props {
			${0}
		};
	</script>
	
	<style scoped>
	
	</style>
	
# Base for Vue.js File with TypeScript using the Composition API plugin for Vue 2
snippet vcompbase
	<template>
	
	</template>
	
	<script lang="ts">
		import Vue from "vue";
		import { defineComponent } from "@vue/composition-api";
	
		export default defineComponent({
			${0}
		});
	</script>
	
	<style scoped>
	
	</style>
	
# Augmenting Types to declare an instance property
snippet v-augmenting
	import Vue from "vue"
	
	declare module "vue/types/vue" {
		interface Vue {
			\$_${1:myProperty}: ${2:type}
		}
	}
	
# Declare additional global properties
snippet v-augmenting-global
	import Vue from "vue"
	
	declare module "vue/types/vue" {
		interface VueConstructor {
			\$_${1:myGlobal}: ${2:type}
		}
	}
	
# Declare additional components options
snippet v-augmenting-comp
	import Vue from "vue"
	
	declare module "vue/types/options" {
		interface ComponentOptions<V extends Vue> {
			${1:myOption}?: ${2:type}
		}
	}
	
# v-for statement
snippet vfor
	<${1:div} v-for="${2:item} in ${2:item}s" :key="${2:item}.id">
		{{ ${2:item} }}
	</${1:div}>
	
# v-model directive
snippet vmodel
	<input v-model="${1:data}" type="text" />
	
# v-model directive number input
snippet vmodel-num
	<input v-model.number="${1:numData}" type="number" step="1" />
	
# v-on custom handler
snippet von
	@${1:eventListener}="${2:handler}"
	
# v-on custom handler with arguments
snippet von-arg
	@${1:eventListener}="${2:handler}(${3:arg}, \$event)"
	
# v-on click handler with arguments
snippet von-click
	@click="${1:handler}(${2:arg}, \$event)"
	
# v-on submit handler with prevent
snippet von-submit
	@submit.prevent="${1:handler}"
	
# Import Component with vue-class-property
snippet vcc-imp
	import Component from "vue-class-component";
	
# Import Vue and Component with vue-property-decorator
snippet vpd-imp
	import { Component, Vue } from "vue-property-decorator";
	
# Class-style API initial data
snippet vcs-data
	${1:name}: ${2:type} = ${3:value};
	
# Class-style API annotate refs type
snippet vcs-refs
	\$refs!: {
		${1:nameComponent}: ${2:Component},
	};
	
# Class-style API computed
snippet vcs-computed
	get ${1:nameComputed} () {
		return ${2:value};
	};
	
# Import Vue
snippet v-imp
	import Vue from "vue";
	
# Import Vue and VueConstructor
snippet vc-imp
	import Vue, { VueConstructor } from "vue";
	
# Definition export default component as VueConstructor
snippet vc-header
	export default (Vue as VueConstructor<Vue>).extend({
	
# Definition export default component as VueConstructor + interface
snippet vco-header
	export default (Vue as VueConstructor<Vue & ${1:Refs}>).extend({
	
# Component typed data as a function
snippet vdata
	data() {
		return {
			${1:key}: ${2:value} as ${3:type},
		};
	},
	
# Vue Props
snippet vprops
	props: {
		${1:propName}: ${2:type},
	},
	
# Vue Props required
snippet vprops-req
	props: {
		${1:propName}: {
			type: ${2:Number},
			required: true,
		},
	},
	
# Interface for extend Vue
snippet vinterface
	interface ${1:nameInterface} {
		${2:key}: ${3:value},
	},
	
# Vue Method
snippet vmethod
	methods: {
		${1:name}(${2:arg}): ${2:typedReturn} {
			${0}
		},
	},
	
# Vue Computed value (must always be typed)
snippet vcomputed
	computed: {
		${1:name}(): ${2:type} {
			return this.${3:data};
		},
	},
	
# Vue watcher
snippet vwatcher
	watch: {
		${1:data}(${2:newValue}, ${3:oldValue}) {
			${0}
		},
	},
	
# Declaration Refs by VueConstructor
snippet vrefs
	interface ${1:Refs} {
		\$refs: {
			${2:name}: HTMLInputElement
		}
	}
	
	export default (Vue as VueConstructor<Vue & ${1:Refs}>).extend({
	
# Vue filter
snippet vfilter
	filters: {
		${1:fnName}(${2:value}) {
			return ${2:value}${0};
		}
	}
	
# Vue render (needs return type)
snippet vrender
	render (createElement): VNode {
		return createElement("${1:tag}", this.${2:computed})
	},
	
